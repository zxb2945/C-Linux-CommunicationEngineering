# 工作五年LINUX的相关整理

## 1 常用命令

### rm -rf xx

r表示递归，f表示强制（强制），用于删除文件夹。

### grep "xx" -r -n ./

该命令用语抓取字符段。

r表示遍历子目录，无所谓大小写，-R亦可；

n（小写）表示显示行数；

“/”表示根目录，“./”表示当前目录，“../”上上级目录；

grep "xx"位置固定，之后参数位置可灵活调换，”xx“冒号可以省略；

“grep xx xx.log"表示在某文件里抓取相应字符。

### find ./ -name "xx"

寻找文件。

-name 表示文件名，“xx”可以不用加冒号；

自动递归，不用r；

"-size +20M"表示查找20M大以上的文件。

### chown -R root:root xx

将文件xx所有者改为root。

root:root 表示 组：名。

### df -h

查看系统硬盘空间。

### less -N xx.c

-N表示显示行号（grep就必须用n，所以参数大小写就比较不统一）。

### ls -l|wc -l

表示当前目录下的文件数。

## 2 linux执行命令结果输出到文件

|                    |                |
| ------------------ | -------------- |
| echo "xx" >文件    | 覆盖写入       |
| echo "xx" >>文件   | 追加写入       |
| xx >/dev/null 2>&1 | 忽略所有的输出 |

“>/dev/null”表示空文件，写进去全部丢失。

"2>&1",0为stdin，1为stdout，2为stderr。1为默认值，"&"表示等同。

也就是说"1 >/dev/null 2>&1",命令执行时屏幕上产生的任何信息写入空文件中，2和1一起写进去。

## 3 GDB(The GNU Project Debugger)

进程包含线程。进程有自己的内存空间，线程与该进程的其它线程共享这个内存，但堆栈各自独立。进程通过IPC（进程间通信）来管理进程间的共享数据。

ps为最基本的进程查看命令。

gdb可直接执行程序文件，并可手动设参，如

```
（gdb）set args SE MODE:IMT ...
```

也可attach当前运行程序，gdb -p  \<PID\> 或 gdb --pid \<PID>  -x xx.c:150 （提前打断点）。

| 多线程调试   |                                          |
| ------------ | ---------------------------------------- |
| info threads | 前面有*的为当前调试的线程                |
| thread ID    | 切换线程，存在断点时会自动切换到断点线程 |
| bt           | 查看线程栈结构                           |

| GDB常用命令        |                                                              |
| ------------------ | ------------------------------------------------------------ |
| r                  |                                                              |
| b fun/N/file.c:N   |                                                              |
| d N                | 删断点                                                       |
| info break         |                                                              |
| c                  |                                                              |
| finish             | 运行到当前函数结束                                           |
| s                  | 进入子函数                                                   |
| return N           | 对当前函数，强制回值并结束                                   |
| p var              | 打印变量，也可赋值                                           |
| set var=val        |                                                              |
| q                  | 退出                                                         |
| info locals        | 打印所有初始局部变量                                         |
| x/\<n/f/u> \<addr> | 比如x/16db 0xXX， 查看该地址16个单位，以十进制单字节显示的值 |
| l                  | 查看代码.c文件（注意编译时机差异.c文件与.o文件不一致情况）   |

## 4 GCC

gcc编译的四个阶段：

|               |                                   |
| ------------- | --------------------------------- |
| Preprocessing | 对include，define分析             |
| Compilation   | -S(大写) 表示生成汇编文件后停止   |
| Assembly      | -c 表示生成目标文件后停止，不链接 |
| Linking       | 链接函数库                        |

链接之前，已是二进制文件，内存已分配完毕。

.a 为静态库，代码全塞进去； .so为动态库，运行时加载（win系统下为.lib和.dll）。

之前微码生成静态库塞到驱动，驱动提供动态库给应用层，比如

```
gcc -shared -fPIC -o libhello.so hello.c /*-fPIC参数声明链接库的代码段是可以共享的，-shared参数声明编译为共享库*/
gcc main.c -L. -lhello /*-L.告诉编译器在当前目录中查找库文件*/
```

gcc最基本的用法就是：gcc [options] [filenames] => gcc test.c （简洁不！）。

| [options] |                                   |
| --------- | --------------------------------- |
| -o        | 若不给，则生成a.out（可执行文件） |
| -Wall     | 编译后显示所有警告                |
|           |                                   |

## 5 ctags

ctags是个程序，3条命令：

|          |                                        |
| -------- | -------------------------------------- |
| ctags -R | 创建tags                               |
| Ctrl + ] | 跳进去，注意只能在有tags文件目录下操作 |
| Ctrl + T | 跳出来                                 |

在Linux下可以用vim + ctags组合来写程序。