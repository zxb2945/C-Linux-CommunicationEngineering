# 计算机基础课程自学回顾

## 网课：C++ 2019.8.14

之前六月份利用早起看完清华大学郑莉的C++课程，一直想做个总结来着，刚才回头又过了遍笔记，觉得有点难。C++几年前自己看过书，尚有点记忆，这次算是系统地重温最基本的概念了。与C通用的不讲，新增了如reference，bool，new/delete等算是语法细节补充。而类/对象包含的知识只能是了解面向对象设计的基本思想，其语法细节关乎多态继承等的虚函数什么的只能说有概念。又比如友元，运算符重载等。To be honest，就算是C语言，目前项目开发中，我发现自己对字符串的理解，库函数的熟悉程度都令人汗颜。想要精通C++，除了最基本的语法，还有对泛型设计思想即模板，STL的熟悉程度无疑是难上加难。即便是科班出身的程序员不用来开发，也会忘得差不多。那么我看这门课的意义主要在于了解面向对象与泛型设计的思想，对C++语法系统过一遍，直到有这个知识点，有迹可循。在这基础上，以后工作有相关项目可以去尝试一下，可以先业余写个魔塔游戏？什么形式的语言只是工具，关键是编程思想。

## 网课：离散数学 2019.9.1

八月中旬历时一个半月在B站上看完北大陈斌老师的《离散数学概论》。分成五分部分：数理逻辑，集合论，图论，抽象代数，形式语言与自动机。

起头很有意思，讲中国古代数学始终停留在计算层面，不像西方经历了三次数学危机，使数学成为脱离观察，直觉与经验的纯粹思维。第一次数学危机是数轴无法表示的无理数，第二次是微积分创立时关于无限无穷的概念，第三次是集合论引出的自我相关，从中看到数学之奇妙！我高中时企图以经验出发把我实质，那时物理是够用的，对数学却是捉急，因为后者内在要求就是超越人类经验的。所以经典物理学尚可以用经验归纳出规律，待相对论及量子力学这种理论非借助数学这个梯子就无以触及，数学真是打破了求知欲的天花板。

讲数理逻辑，最基础的是命题逻辑和谓词逻辑。简而言之，前者的逻辑联结词为∧，∨，->等，做抽象形式化处理后成为命题公式，本质上是真值函数（布尔）。通过逻辑等价，有一套演算系统，可以确定一个主范式。但其无法表现不同命题之间的联系，比如三段论，只能是对确定的对象做出真值判断。在这基础上，加上量词ᗄ，∃就是谓词公式，谓词逻辑就可以讨论不确定性。数理逻辑还有其它方向，但基本建立在以上两者基础上，比较实用的就是德摩根定律【非(P 且 Q) = (非 P) 或 (非 Q)；非(P 或 Q) = (非 P) 且 (非 Q)】。

集合是现代数学中比数更为基础的概念，不做定义，只通过公理来描述的初始概念，是整个数学的基础。集合的集合即是集合族。将{{a},{a,b}}称为二元有序组，简记为<a,b>，定义笛卡尔积A1xA2={<u,v>|u∈A1,v∈A2}，是有序组的集合。若R是笛卡尔积A1xA2的子集，则R为A1到A2的二元关系，简记为A1RA2。特殊的关系有等价关系和函数，前者可举例三角形的相似关系：自反，对称，传递。可以引出划分这个概念。有限集合一个不空不漏不交的子集族，集合族关系与划分均可以定义出一系列运算来，可在各自定义域内封闭。

图论起源于科尼斯堡七桥问题，即一笔画问题，抽象为点线组合。两点之间的连接方式即拟路径，可分为边各不相同的路径walk与顶点各不同的通路path。两者出入点相同则称为闭路径与回路，此概念而来著名的图有欧拉图与汉密尔顿图。此外，二分图常用于匹配问题。平面图用于电路板线路不交叉问题。树tree即使二分图也是平面图，二元树对应数据结构中的二叉树，其遍历问题比较经典。

抽象代数是抛弃代数结构（例如自然数上的加法运算可记为<N,+>,又比如矩阵的运算）中对象集合与运算的具体意义，研究运算的一般规律。举例说，比如<R,+>与<R,x>为同态映射，此正是加法与乘法许多相似的原因。代数结构有许多类型如群环域，但课程中没有细讲，与幺元（如乘法中的1），零元（乘法中的0），反元（1/2x2=1，互为反元）等基本概念有联系。

形式语言与自动机这一章节有意思，以前中文专业中有语言学的内容嘛。Chansky对语言的定义为按照一定规律构成的句子和符号串有限或无限的集合。形式语言研究语言描述的问题，比如语法描述，通过有限替换规则，生成合格的句子。典型有短路结构语法（四元组）。又比如自动机，像有限状态自动机（五元组）就可以检验正则语言，常用来定义检索模式。正则语言也可以用正则表达式表示，如ab*描述{a,ab,abb,...}，是编程中很常用的概念。最后讲图灵机（分格无限长的纸带），可用来检验0型语言，其停机问题不可解。

总的而言，离散数学是计算机专业相当基础的一门课，有其垫着，才能进一步去了解数据结构与算法，编译原理等课程。跟之前C++一样有十七八小时。

## 网课：Linux 2019.10.20

年初面试时，对方问程序实在Linux上编译的吗？竟回答不上来，回想之前用了一年半的Linux系统，但却对它一无所知，连.so和.a区别都不知道，虚拟机vmware和测试盘有什么区别？写TCL自动化脚本时用了awk，但回头想什么也没记起来。过去两个月在B站上看了尚硅谷韩顺平的Linux教程以及中国科大孟宁的《Linux内核讲解》，加之新工作入职大半年的钻研，对Linux才有了个基本的了解。

我认为对Linux的认识可以分为三个层次。首先是内核层面的。孟宁在六个小时多的视频中从x86寄存器和常用汇编指令讲起，着重讲了函数调用时栈的变化过程，接着分析内核源代码（提到C中内嵌汇编代码，操作系统基本用C写），以sys.time为例说明了system call的使用过程，此外需清楚用户态和内核态，通过中断处理的切换过程，以及层次状况。然后开始讲进程，PCB的结构体介绍（讲道理2016年刚参加工作时候相关内容的书也看过，但没与工作结合，故而印象浅薄）。进程创建时，fork同时返回父子进程两个信号，特殊点。另一个特殊的系统调用是可执行程序装载时，execve进入内核后再出来已是另一个进程这个替换。最后讲进程的调度，进程上下文的切换与硬件上下文切换的区别（前者是两个进程间的行为，后者一个）。以上大部分操作系统的知识点，从Linux角度讲解，受益匪浅。

其次，可以结合韩顺平的视频讲，即交互层面。首先Linux下一切皆文件，其根目录命令行式的交互界面，像工作中用TeraTerm与WinSCP来进行Windows和Linux的交互，之前工作也一样。一些基本的操作指令就不说了，总数有250条左右。然后对vim的使用像yy，p这种复制拷贝以及高亮搜索翻页至少要知道，跟sakura以及SourceInsight一样是代码文本编辑器。还有用户管理，网络配置这部分的介绍（对开发要求不高吧，运维会比较关心）。一般来说，Windows能做到的Linux也行，上网收发邮件下载软件（YUM）等，甚至装Eclipse等IDE。在这个层面上最关键的当是shell脚本开发。Linux命令行界面本身就是一个交互式shell。那些shell script是非交互式的。在这基础上，理解各种变量，尤其是export环境变量（之前依样照葫芦敲进去却完全不知道其背后原理，惭愧），位置参数变量$n，预定义变量$!,$?...运算式的格式要求，判断式，流程控制等及函数部分：系统函数，自定义函数。在操作Linux过程中，会写shell脚本很基础，可以用于批量操作，定时运维等。

最后，是对C/C++开发而言的一些工具程序，GDB与GCC的操作，makefile的编写。并且，Linux文本处理三剑客grep，sed与awk。各自长处领域得有概念啊。以上只是些基础，说熟悉Linux仍然是不够，只能讲基本的Linux框架OK了，面试时吹个牛也知道个方向。

## 网课：数据结构与算法 2020.1.12

## 网课：计算机网络 2020.3.29

## 网课：数据库原理 2020.7.4

## 网课：计算机构造与解释 2020.10.2

## 网课：编译原理 2021.1.8

## 书籍：编码的奥秘 2019.6.30

## 书籍：程序员的自我修养 2019.12.31

## 书籍：计算机构造与解释python版 2021.3.19

是上个月看完 Structure and Interpretation of Computer Programs的Python版本。前天又花了一天时间回顾。真是大开眼界，给你一种完全不同的视角看待程序语言，正如书中所言的magic，art，比如我们都知道program是由procedure和data构成，但我从没想过procedure就是data，data就是procedure。就Python入门而言，对一个C语言程序经验者，这本书非常难懂，难懂在于它的讲述方式跟传统的填鸭式介绍控制语言，数据结构...完全不同，但我反过来想如果对于初心者而言，或许就没有别样的难。当然本书与其说讲解Python，还不如讲是一种通用的程序语言概念，最核心的无非就是抽象和递归，只是拿Python举例了。

第一章讲procedure。程序语言中最基本的概念是什么？表达式（最基础的就是数值本身）和 表达式的绑定。在Python中，在一定范围内的自然数，都是有独立地址的，比如

```
a = 5，b = 5
```

a和b地址就相同，所以相对于C，`=`更确切讲是绑定而不是赋值，`=`提供了最基础的抽象手段。然后是调用表达式（数值+运算符）。运算符本质上就是函数，这里就引出了第一章的主题，函数。进一步稍微复杂一点，函数可以嵌套，提供了组合操作手段。函数由什么组成？语句。表达式、返回语句return和赋值语句等是最简单语句，跟C相较，因为Python可以是屏幕上交互式语言，所以像123这样单独数值的表达式就是一条独立的语句，逗号在赋值语句中分隔了多个名称和值，比如

```
a,b=1,2
```

（这本书很多东西都讲到C基础Python语言学习者的盲点上，有时候正是受困于既定思维，所以阅读此书时方才更为困难）。简单语句其基础上有def（定义），if（条件控制），while（重复）等复合语句。Python 的代码是语句的序列（语句的序列实质上也是个first+rest的递归结构）。一条简单的语句是一行不以分号结束的代码，复合语句一般占据多行，并且以一行以冒号结尾的头部开始，它标识了语句的类型。同时，一个头部和一组缩进的代码叫做子句（借助简单复合语句的概念，去理解Python与C书写格式上的异同）。函数作为一个整体可以作为参数，返回值，跟最基本的表达式一样是语言的一等元素，可以被嵌套定义，高阶函数可以像操作数据一样去操作函数，这里就可以理解为什么procedure是data。Python中对一些没有赋值和控制语句单个返回表达式的函数可以用Lambda 表达式，有点类似于C中的difine，但进一步具有匿名性（即不存在函数名）。此外，还顺道讲了一个语法糖：装饰器，结构上非常费解然而又精巧，用于不修改高阶函数原有代码的前提下对高阶函数功能追加。

第二章讲data。Python 包含了三个原始数值类型：整数（`int`）、实数（`float`）和复数（`complex`）。之后所有的抽象数据类型都是基于此构建起来，最终形成一个Python大厦。首先书中通过有理数的构造过程，来展示抽象的层次。表现为几分之几的有理数数据结构由二元元组(偶对的形式)来实现，而偶对的下标访问方式以及有理数数据结构的运算都能以函数操作原始数值类型来实现（从这个角度上看，偶对或者所构造的有理数就是一个函数，这就说明了为什么data是procedure）。偶对到多元元组就一回事。

这个节点，书中引入了`nonlocal`语句，我们知道函数也是一种数据类型，书中特地分了纯函数和非纯函数，它们之间最本质的区别就是是否可变。前者只要特定的参数，return肯定是不变的，后者假若引进nonlocal变量，return值就是可变的。这里隐含了一个赋值语句的双重作用：创建新的绑定，或者重新绑定现有名称。为了去补救重新绑定的操作引起的认识论问题：它对于两个相同的值意味着什么。（如果清楚C中指针的概念的话，其实就很好理解）。对于不可变类型，值相同对象就相同，对于可变类型就不尽然。所以Python 引入了两个比较运算符，叫做`is`和`is not`，测试了两个表达式实际上是否求值为同一个对象，`is`和是个比相等性`==`更强的比较运算符。

偶对可以嵌套，满足封闭性（封闭性在任何组合手段中都是核心能力），去实现

```
(1, (2, (3, (4, None))))
```

这样的嵌套结构。这个嵌套的结构通常对应了一种非常实用的序列思考方式，一个非空序列可以划分为：它的第一个元素，以及序列的其余部分。这说明了列表是可以基于偶对递归实现，并用函数实现元素的变更（ps Python 的内建list序列类型以不同方式实现）。(传统Python介绍中先介绍list，再是tuple，然后要去解释为什么有了list后还要创造tuple？因为list基于tuple基础上实现嘛，由此可见本书编排精妙之一斑。) 

字典的目的是提供一种抽象，用于储存和获取下标不是连续整数，而是描述性的键的值。所以字典实现上可以通过列表改造而来。至此就完成了从偶对到字典的主要序列容器的构建。（书中还顺手组合了非局部赋值、列表和字典来构建一个基于约束的系统，支持多个方向上的计算。这真是开了我的眼界，理解连接器和约束，把它们看成key为函数名，value为函数过程去理解，最新颖在于这个这个基于约束网络特征的无方向计算。）

我们知道序列的许多操作都是基于迭代的概念，这里就可以引进迭代器。有序序列其实隐含着迭代器接口`__iter__`和`__next__`，Python 拥有额外的控制语句来处理序列数据：`for`语句。

```
>>> counts = [1, 2, 3]
>>> for item in counts:
        print(item)
1
2
3
```

如上例，counts可以通过`__iter__`回应给`for`一个迭代器，然后`for`反复调用`__next__`来实现对序列的遍历。可以通过`while`显式地配合`__next__`来实现`for`语句。程序中的一个常见模式是，序列的元素本身就是序列，`for`语句可在头部中包含多个名称，将每个元素序列“解构”为各个元素。这个绑定多个名称到定长序列中多个值的模式，叫做序列解构。它的模式和我们在赋值语句中看到的，将多个名称绑定到多个值的模式相同。如果不需要解构序列元素，常见的惯例是将单下划线字符用于`for`头部，要注意对解释器来说，下划线只是另一个名称，但是在程序员中具有固定含义，它表明这个名称不应出现在任何表达式中。（这本书说明Python完全是另一套思维，不是既存的`for`去操作序列，而是序列的某些特性需要引入`for`语，而且说`for`语法的每一个点都说到心坎上去了，相较于C，Python中`for`的改造在哪里？妙不可言！其实深入思考一下，C语言中`while`和`for`在汇编层面是一样的，但Python中不然，就因为这个迭代器概念。）

`for`语句常跟`range`配合使用，如

```
>>> for _ in range(3):
        print('Go Bears!')

Go Bears!
Go Bears!
Go Bears!
```

`range`事实上是一种隐式序列，迭代器提供了一种机制，可以依次计算序列中的每个值，但是所有元素不需要连续储存。反之，当下个元素从迭代器获取的时候，这个元素会按照请求计算，而不是从现有的内存来源中获取。这是惰性计算的一个例子。计算机科学将惰性作为一种重要的计算工具加以赞扬。

生成器表达式组合了过滤`filter`和映射`map`的概念，并集成于单一的表达式中，以下面的形式：

```
<map expression> for <name> in <sequence expression> if <filter expression>
```

表达式包含了`map`和`filter`的大部分功能，但是避免了被调用函数的实际创建，实际上也是一种惰性计算。

生成器函数是一种特殊的迭代器，不同于普通的函数，因为它不在函数体中包含`return`语句，而是使用`yield`语句来返回序列中的元素。`yield`与`return`的区别在于，它返回值出去之后仍然可以在当前位置继续执行下去，利用这点可以去构建Python中一种轻量级的线程，即协程（coroutine）。

流提供了一种隐式表示有序数据的最终方式，流是惰性计算的递归列表，就像之前自偶对嵌套构建而来的`list`那样，`Stream`类实例化后可以响应对其第一个元素和剩余部分的获取请求，同样，`Stream`的剩余部分还是`Stream`，然而不像`list`，流的剩余部分只在查找时被计算，而不是事先存储，也就是说流的剩余部分是惰性计算的。（惭愧惭愧，C++中多次接触流，但始终没有理解其本质）。

讲流时提到了对象，而对象正是基本数据抽象最上层的概念，事实上可以通过在实例、类和基类之间发送含有属性的字典作为消息来实现对象系统，只是没法去实现点运算符，书中讲点运算符是 Python 的语法特征，它形成了消息传递的隐喻。（类与方法之间的点可以视作为一个运算符。其实我这个浸淫C多年的coder刚看Python就对这个点运算符比较懵逼。）点运算符隐式地把方法的第一个参数设为了self。可以在pycharm中使用debugger来追踪书中所列出来的例子看一下类与对象是如何建立起来的。先创建类，从外层的类到基类，调用层层深入进去，然后实例化对象，从基类开始往外依此调用初始化函数最终抵达实例。比喻来说，创建时先一层层进去拿到最核心的字典，即基类的字典，然后实例化时在从这个核一层层出来，包裹各层次之间的颜料，最后形成实例。每一个层次的字典（可以理解为方法集）都不一样，就可以理解类与对象各自有相应的方法，某种程度上类似于类与基类，从而也能理解各个层次间方法重载的机制，先是调用实例中的方法，如果找不到，就去类中寻找，并绑定到实例中执行。（另一方面我们也可以理解为什么C的编译器可以用C来编写，因为就如同Python的某些机制如类与对象可以由更为低层次的抽象概念字典与函数来实现一样，语言的建构是一个不断抽象累积的过程。）

第三章实现了一个解释器，前面两章分别讲了编程的两个基本元素procedure和data，事实上，procedure就是data这一点，也可以从用户的程序即是解释器的数据的角度来理解。本章最后有介绍Lsip的两种方言Scheme和Logo的解释器构造：数据求值粗略地来说可以得到基本表达式和函数，这个函数就需要调用过程，而过程中去读取每一行的代码有需要递归去调用数据求值来确定值，从而数据求值与过程互相递归，最终停止于基本表达式。

关于这两种抽象语言的解释器框架，我确实也只一知半解，但能够意识到其核心就是递归：可以通过C写一个Fibonacci数列的递归调用，从汇编层面去理解递归函数：函数前半段不断重复进去递归函数内层，然后后半段不断重复出来到最外层。书中说我们不应该关心`fun(n-1)`如何在`fun`的函数体中如何实现，只需要相信它计算了`n-1`的阶乘，将递归调用看做函数抽象叫做递归的“信仰飞跃”（leap of faith），这说得真好！递归与迭代思考方式上是截然不同的，通常，迭代函数必须维护一些局部状态，它们会在计算过程中改变。在任何迭代的时间点上，状态刻画了已完成的结果，以及未完成的工作总量。

书中以较抽象语言更为简单的计算器语言的解释器构造为例来抛砖引玉，介绍之前先需介绍两个概念：表达式树和字符串。就像第二章介绍的递归列表，树同样可以通过偶对嵌套的封闭性来构造，这里引入Python除tuple，list，dictionary之外第四种容器set来说明树的高效性，set可以由无序集合，有序集合和平衡二叉树集合来实现，它们对于集合的交并等计算而言，效率差别很大。（这些事实上是算法和数据结构的内容，加上编译原理，本书内容其实非常丰富。）

然后是字符串，字符串满足基本的序列容器条件，数据值的字符串表示在类似 Python 的交互式语言中尤其重要，其中“读取-求值-打印”的循环需要每个值都拥有某种字符串表示形式。Python中主要有两种字符串构造函数`str`和`repr`，略有区别。与之紧密相关的概念是接口，响应`__repr__`和`__str__`特殊方法的对象都实现了通用的接口，它们可以表示为字符串，这某种程度上是函数多态的一种表现。（JAVA中抽象类ADT与接口的区别不是常提的嘛）。

回到计算器语言的构造，仍然是可以用pycharm中的debugger来看书中的例子，其基础是构建一个表达式树的类来作为计算器语言的基本对象，比如`add(1,2)`,由operator和operand构成(注意这个类本身可以递归表示为operand，形成复合计算式）。在“读取-求值-打印”循环的交互模式中（一个loop函数），利用词法分析器lexical analysis切割所输入的字符串（代码文本）产生一个token列表，然后利用语法分析器parse去生成表达式树（这里要构建一个递归逻辑去实现复合计算式的实现），中间通过异常机制健壮语法错误检查，最终将表达式树输入计算逻辑函数即semantic analysis得出结果，即输入符合语法的字符串（代码文本）被相应执行。（就C编译器而言，相对Python解释器，多optimization和code generation两个步骤，但前三步原理一样，这比看编译原理简单明了多了！）

之前有看过Lisp版本SICP的英文视频，就是完全云里雾里，也看过浙大python的教学视频，感觉就填鸭死记硬背，等到看了这本Python版本的SICP，非常惊喜，回味起来就感慨这本书的编排之美丽，果真是magic，art。明白别人所讲的：永远不要做一个不知道递归和抽象概念的程序员。