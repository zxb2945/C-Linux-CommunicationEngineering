# 计算机基础课程自学回顾

## 网课：C++ 2019.8.14

之前六月份利用早起看完清华大学郑莉的C++课程，一直想做个总结来着，刚才回头又过了遍笔记，觉得有点难。C++几年前自己看过书，尚有点记忆，这次算是系统地重温最基本的概念了。与C通用的不讲，新增了如reference，bool，new/delete等算是语法细节补充。而类/对象包含的知识只能是了解面向对象设计的基本思想，其语法细节关乎多态继承等的虚函数什么的只能说有概念。又比如友元，运算符重载等。To be honest，就算是C语言，目前项目开发中，我发现自己对字符串的理解，库函数的熟悉程度都令人汗颜。想要精通C++，除了最基本的语法，还有对泛型设计思想即模板，STL的熟悉程度无疑是难上加难。即便是科班出身的程序员不用来开发，也会忘得差不多。那么我看这门课的意义主要在于了解面向对象与泛型设计的思想，对C++语法系统过一遍，直到有这个知识点，有迹可循。在这基础上，以后工作有相关项目可以去尝试一下，可以先业余写个魔塔游戏？什么形式的语言只是工具，关键是编程思想。

## 网课：离散数学 2019.9.1

八月中旬历时一个半月在B站上看完北大陈斌老师的《离散数学概论》。分成五分部分：数理逻辑，集合论，图论，抽象代数，形式语言与自动机。

起头很有意思，讲中国古代数学始终停留在计算层面，不像西方经历了三次数学危机，使数学成为脱离观察，直觉与经验的纯粹思维。第一次数学危机是数轴无法表示的无理数，第二次是微积分创立时关于无限无穷的概念，第三次是集合论引出的自我相关，从中看到数学之奇妙！我高中时企图以经验出发把我实质，那时物理是够用的，对数学却是捉急，因为后者内在要求就是超越人类经验的。所以经典物理学尚可以用经验归纳出规律，待相对论及量子力学这种理论非借助数学这个梯子就无以触及，数学真是打破了求知欲的天花板。

讲数理逻辑，最基础的是命题逻辑和谓词逻辑。简而言之，前者的逻辑联结词为∧，∨，->等，做抽象形式化处理后成为命题公式，本质上是真值函数（布尔）。通过逻辑等价，有一套演算系统，可以确定一个主范式。但其无法表现不同命题之间的联系，比如三段论，只能是对确定的对象做出真值判断。在这基础上，加上量词ᗄ，∃就是谓词公式，谓词逻辑就可以讨论不确定性。数理逻辑还有其它方向，但基本建立在以上两者基础上，比较实用的就是德摩根定律【非(P 且 Q) = (非 P) 或 (非 Q)；非(P 或 Q) = (非 P) 且 (非 Q)】。

集合是现代数学中比数更为基础的概念，不做定义，只通过公理来描述的初始概念，是整个数学的基础。集合的集合即是集合族。将{{a},{a,b}}称为二元有序组，简记为<a,b>，定义笛卡尔积A1xA2={<u,v>|u∈A1,v∈A2}，是有序组的集合。若R是笛卡尔积A1xA2的子集，则R为A1到A2的二元关系，简记为A1RA2。特殊的关系有等价关系和函数，前者可举例三角形的相似关系：自反，对称，传递。可以引出划分这个概念。有限集合一个不空不漏不交的子集族，集合族关系与划分均可以定义出一系列运算来，可在各自定义域内封闭。

图论起源于科尼斯堡七桥问题，即一笔画问题，抽象为点线组合。两点之间的连接方式即拟路径，可分为边各不相同的路径walk与顶点各不同的通路path。两者出入点相同则称为闭路径与回路，此概念而来著名的图有欧拉图与汉密尔顿图。此外，二分图常用于匹配问题。平面图用于电路板线路不交叉问题。树tree即使二分图也是平面图，二元树对应数据结构中的二叉树，其遍历问题比较经典。

抽象代数是抛弃代数结构（例如自然数上的加法运算可记为<N,+>,又比如矩阵的运算）中对象集合与运算的具体意义，研究运算的一般规律。举例说，比如<R,+>与<R,x>为同态映射，此正是加法与乘法许多相似的原因。代数结构有许多类型如群环域，但课程中没有细讲，与幺元（如乘法中的1），零元（乘法中的0），反元（1/2x2=1，互为反元）等基本概念有联系。

形式语言与自动机这一章节有意思，以前中文专业中有语言学的内容嘛。Chansky对语言的定义为按照一定规律构成的句子和符号串有限或无限的集合。形式语言研究语言描述的问题，比如语法描述，通过有限替换规则，生成合格的句子。典型有短路结构语法（四元组）。又比如自动机，像有限状态自动机（五元组）就可以检验正则语言，常用来定义检索模式。正则语言也可以用正则表达式表示，如ab*描述{a,ab,abb,...}，是编程中很常用的概念。最后讲图灵机（分格无限长的纸带），可用来检验0型语言，其停机问题不可解。

总的而言，离散数学是计算机专业相当基础的一门课，有其垫着，才能进一步去了解数据结构与算法，编译原理等课程。跟之前C++一样有十七八小时。

## 网课：Linux 2019.10.20

年初面试时，对方问程序实在Linux上编译的吗？竟回答不上来，回想之前用了一年半的Linux系统，但却对它一无所知，连.so和.a区别都不知道，虚拟机vmware和测试盘有什么区别？写TCL自动化脚本时用了awk，但回头想什么也没记起来。过去两个月在B站上看了尚硅谷韩顺平的Linux教程以及中国科大孟宁的《Linux内核讲解》，加之新工作入职大半年的钻研，对Linux才有了个基本的了解。

我认为对Linux的认识可以分为三个层次。首先是内核层面的。孟宁在六个小时多的视频中从x86寄存器和常用汇编指令讲起，着重讲了函数调用时栈的变化过程，接着分析内核源代码（提到C中内嵌汇编代码，操作系统基本用C写），以sys.time为例说明了system call的使用过程，此外需清楚用户态和内核态，通过中断处理的切换过程，以及层次状况。然后开始讲进程，PCB的结构体介绍（讲道理2016年刚参加工作时候相关内容的书也看过，但没与工作结合，故而印象浅薄）。进程创建时，fork同时返回父子进程两个信号，特殊点。另一个特殊的系统调用是可执行程序装载时，execve进入内核后再出来已是另一个进程这个替换。最后讲进程的调度，进程上下文的切换与硬件上下文切换的区别（前者是两个进程间的行为，后者一个）。以上大部分操作系统的知识点，从Linux角度讲解，受益匪浅。

其次，可以结合韩顺平的视频讲，即交互层面。首先Linux下一切皆文件，其根目录命令行式的交互界面，像工作中用TeraTerm与WinSCP来进行Windows和Linux的交互，之前工作也一样。一些基本的操作指令就不说了，总数有250条左右。然后对vim的使用像yy，p这种复制拷贝以及高亮搜索翻页至少要知道，跟sakura以及SourceInsight一样是代码文本编辑器。还有用户管理，网络配置这部分的介绍（对开发要求不高吧，运维会比较关心）。一般来说，Windows能做到的Linux也行，上网收发邮件下载软件（YUM）等，甚至装Eclipse等IDE。在这个层面上最关键的当是shell脚本开发。Linux命令行界面本身就是一个交互式shell。那些shell script是非交互式的。在这基础上，理解各种变量，尤其是export环境变量（之前依样照葫芦敲进去却完全不知道其背后原理，惭愧），位置参数变量$n，预定义变量$!,$?...运算式的格式要求，判断式，流程控制等及函数部分：系统函数，自定义函数。在操作Linux过程中，会写shell脚本很基础，可以用于批量操作，定时运维等。

最后，是对C/C++开发而言的一些工具程序，GDB与GCC的操作，makefile的编写。并且，Linux文本处理三剑客grep，sed与awk。各自长处领域得有概念啊。以上只是些基础，说熟悉Linux仍然是不够，只能讲基本的Linux框架OK了，面试时吹个牛也知道个方向。

## 网课：数据结构与算法 2020.1.12

去年底三四个月时间看B站清华邓俊辉的Data Structure & Algorithm. 是计算机专业的核心课程，leetcode上刷算法基础就在这。大学学了门C，直到冒泡排序和链表...如此而已。之前前辈有跟我提vector和list各自优缺点以及归并算法，我就觉得很新奇，这边一看，是课程中最为基础的知识点，汗颜！

课程开篇先高屋建瓴地讲算法分析概念，n^2->2^n就是算法是否有效的分水岭，讲大O的估算模型怎样去繁就简，以最长公共子序列与斐波那契计数问题为例讲递归如何通过动态规划消去重复操作成为迭代，阐述了分而治之和减而治之两个重要思想。

之后就分篇介绍各种containers了。最基本的线性结构vector和list，说明归并排序如何优于冒泡排序；以两者为基础的stack和queue，尤其是stack。因为电脑与人脑机制不同，必须借助stack来实现进制转化，括号匹配以及中缀表达式（即1+1=2形式）；接着讲半线性结构binary tree，同事经常挂嘴边的二叉树。着重说明其三种遍历算法以及重构条件；非线性结构graph其实就简略提了一下；然后就花大篇幅讲balanced binary search tree，结合了向量与列表的优点，大致顺BST->BBST->AVL（两边平衡值可差1）理了遍；扩展到其它各具用途的树，利用某些数据访问具有局部性，将常用数据聚集于根部的伸展树，为实现更高级的IO操作的B树，支持对历史版本访问的红黑树；树之后讲hash（散列），借助hash函数，如除余法，对空间进行压缩，关键点在于冲突排解的方式；priority queue（优先级队列），就是get max问题，采用的是完全二叉堆，即以向量为形BBST为神，实现PQ，另外为方便堆合并过程，有左式堆的概念；之后讲串匹配，依此介绍KMP算法，通过构造next表避免重复匹配前缀。BM算法，从末字符开始匹配。Karp-Robin算法，凡物皆数的思想；最后是一些排序算法介绍：Quicksort, Quickselect, Linearselect, Shellsort, 大体是分而治之和减而治之思想的体现。

以上是非常简略过了遍30小时左右课程的主要内容，目的是脑中留个概念，往后碰到相关词汇有据可查，即索引表。

## 网课：计算机网络 2020.3.29

年初两个月在B站上学习了韩立刚的《计算机网络》，之前公司前辈推荐的。那老师讲高校中讲时偏理论，这门课就很抽象，他本身是网络工程师，结合设备就更清晰，加之自己之前交换机开发经验，这门课过一遍，自己综合性理了遍头绪，许多地方有了提纲挈领的认识。上次公司前辈问我IP地址与mac地址有什么区别？我居然没回答上来，惭愧。IP地址决定最终去哪里，mac地址决定下一条去哪，可见之前工作缺乏网络通信知识系统学习。

《计算机网络》主要就是讲解了OSI分层模型。这分层思想你不能局限于数据头嵌套：以太头嵌套IP头嵌套TCP头...否则你就没法理解物理层的电流与链路层帧的区别，电流与包与段是不同层次识别的对象，互相间区别划分标准是一样的。

物理层讲什么呢？什么信道复用技术，编码调制方式，奈式准则，香农公式...不感兴趣，无关紧要跳过（自学就是目的性学习，效率就高）。最简单的就是光纤，以前机房看得多吧。还有一点就是物理层中继设备集线器，就是现在工作台前那网线接头，即hub与链路层设备交换机的区别，前者蠢，只会广播，后者是有mac储存学习能力的。之前面试就把hub与交换机搞混淆了。并且，与无线路由也不一样，WIFI那个实质上有AP(Access Point，相当于有线网路集线器)，交换机，路由三个层次的功能，因此称作路由器没问题。

数据链路层，就是之前我做交换机芯片驱动层coding处，数据帧抓过不少。Ethernet协议之外，还有PPP协议（两个Router通信，ADSL拨号等）。前者才有MAC地址概念。Cisco建网三层模型，接入层（hub？），汇聚层（二层交换机），核心层（三层交换机），脑子里要有图。之前做的就是二层交换机一个盘上一块转发芯片上的编程工作，基于MPLS的VPN。MPLS是2.5层，路由器转发就不必解析IP数据包，凭标签就可以找下一跳， L2VPN(VPWS,VPLS)，L3VPN等概念当初学习得够久。MAC地址学习机制，QoS： ACL(Access Control List), Meter(流量控制)，线性保护技术FRR，PW1:1等就是那一年半主要开发维护的技术嘛，你说你自己究竟多清楚也不尽然，只知概念，惭愧，脑筋还是少动。当然课程中没涉及到MPLS。

网络层，得益于之前做过的一份各式报文的构造过程总结，对ARP，ICMP(比如ping)，IGMP，OSPF，RSVP等耳熟，除了ARP(通过IP找MAC地址)，其余均是承载在IP上的，只是IP头协议号不同，均是网络层协议。有这个知识听课过程对课件中图例就会更深的理解。了解一下ARP攻击，怎样窃取数据包，之前进公司给电脑配置网关，子网掩码就不会像无头苍蝇那样了；

传输层，TCP协议，三次握手，可靠传输，分段，课程里对怎样用窗口划动技术去保证流量控制，网络拥塞讲得很详细。与之相对的就是UDP协议，不可靠传输，如QQ消息。值得留意的是套接字（socket）概念：比如TCP头部前两行就是源端口，目的端口，将不同应用层协议发到对面地址的不同应用，这个端口号+IP地址即是socket，相当于TCP的两个端点之一。防火墙机制就源于这个端口号。

应用层，OSI中实际上还细分为会话，表示，应用三层，各种加密解锁等层次，课程没细讲。比如访问网站过程，其实分解开了有许多步骤，首先ARP找网关出去，DNS解析网址，TCP三次握手建立会话，最后HTTP接受数据。像douban.com是域名，movie，music等前缀就是其中的主机。自己电脑可利用DHCP服务器动态配置IP。DNS和DHCP都是应用层协议，对应不同的端口。此外，FTP协议，像现在在使用的WinSCP实际上就是个图形化SFTP客户端，同时支持SCP协议。Telnet就不讲了，天天去连接远程服务器，RDP远程桌面登录。收发邮件时配置的SMTP，POP3/IMAP也是应用层协议，要理解邮箱服务器就是两个邮局，从163.com下载文本到本地客户端。最后是HTTP协议，现在工作上的通信协议，网站多是URL，HTML，工作上数据部分用的是Json格式，但协议均是HTTP。关于几种操作手段GET，POST，DELETE，PUT，各种接口操作就是这些的包裹，反信200，204，410，500等在工作测试中各种确认，可以说是比课程讲解要了解的更深一点。

网络安全，有介绍病毒，蠕虫，木马，逻辑炸弹等多种恶意程序。

最后两章讲IP电话与无线网络，讲得略简，但恰好是与自己当下工作密切相关的。因此，《计算机网络》这门课没学，我之前的工作几乎是摸着石头过河，但反过来说，工作后重温，互相佐证，就看得特别有意思。话说当前得工作内容，框架性地说明下：首先，是通信发展史，2G/3G时代，日欧与北美用的是两套标准，到4G时代才统一成LTE。2G/3G时代是电路交换CS与分组交换PS并存的，到4G是全网IP化时代，日本2G采用的是GSM标准，过渡到3G时引入了GPRS，我推测是在这个节点导入IMS的，即IP化的核心网。4G时代音声从CS变成了PS，IP化，即VoLTE，粗略讲VoLTE=LTE+IMS。我认为LTE应该是接入网。

再者，我所参与开发的就是这LTE网，其核心框架成为EPC，即LTE交换局，从接受手机信号的基站eNode到接入核心网PDN的Gateway的各种设备，用于地址登录的MME，用户签约信息的HSS等。与之并存的3G无限接入收容网中对应设备为NodeB，SGSN，HLR/VLR。

我所参与开发的设备称为SCP，HSS相当，用于处理用户的契约，在圈信息，全日本有二十多套吧。操作系统和数据库是分离的，分别叫做FSCP和DSCP。其中FSCP又分成FS/FEP，USP两部分。FS用来接收HTTP/SO协议，FEP是收发Diameter和MAP协议。我所开发的程序位于USP上（各种分离主要是确保故障发生时可以切换）。

所参与开发的程序用于各种业务的呼处理。架构上是两条线程，线程间用队列消息通信（这里认识错误，仅仅是用mutex_lock来调度）。数据收发采用HTTP协议，数据部分用Json格式。有契约创建删除，用户信息更新，电话号码获取各种API提供出去。测试时从模拟呼出设备收到HTTP，访问DSCP，用Diameter协议跟4G设备通信，MAP协议跟3G设备通信共同完成任务处理。

去年一整年全组十几个人就是从0开始写代码，与之前那种增量开发比较，对整个程序开发流程还是会有更深的理解。

## 网课：数据库原理 2020.7.4

## 网课：计算机构造与解释 2020.10.2

## 网课：编译原理 2021.1.8

## 书籍：编码的奥秘 2019.6.30

本周花了两天上班空闲时间看完同事推荐的《编码的奥秘》。从摩尔斯电码讲到现代计算机的组成，科普好书。怪不得科班出身的程序员对买电脑如数家珍，毕竟是专业嘛。

书中讲哲学与数学的交际就是逻辑，现代计算机理论就是从布尔代数引出的集合论与串并联的电路技术为基础发展起来的。将人类选择十进制更像是个偶然，二进制才是最为简洁的。但也正因为这个二元性，数字计算机不能处理连续事件，像浮点型数据只能是近似值，精确表达只能通过存储空间更大的BCD码。“每个字节都可以用两个十六进制表示”，也就是说，“一个十六进制是半个字节”。可以用继电器，电线，开关，灯泡组成一个巨大简陋的原始计算机，甚至可以用纸条上打卡来存储数据。到微观层面，CPU构成可以从加法器与锁存器讲起，像RAM为什么是易失性存储器，因为它本质上是电流与金属弹簧片的作用。硬盘能够断电后仍存储，是因为它是磁盘，利用磁介质长时间存储数据。据说要用500万个继电器，才能构成一个64KB的RAM阵列，显然不实用。上世纪六七十年代用晶体管为代表的半导体来取代，此即芯片为首的集成电路产业。微处理器(CPU)即芯片上的计算机，Intel和Motorola首先涉足，各自建立了高低位有别的存储系统。微处理器结构采用RISC，为了提高处理器速度，CPU与RAM之间还有Cache。书中还对各种最基础的执行机器语言的指令有介绍，可以逐一翻译成汇编语言，逐渐往上到高级语言，可知这个体系已经是非常抽象了。锁存器就是寄存器register，像堆栈stack就是中存储器技术，是不被别的东西使用的正常的RAM的一部分。（感慨自己对内存的理解不足很大一部分原因是缺少硬件理论的知识。）现在回想起来对书中出现的ROM，DMA，BIOS，DAC，ADC等术语有些熟悉是自己在工作之初有在杭州图书馆看过嵌入式系统的相关书籍，可见保持读书习惯还是很重要的。ASCII码是计算机界最重要的标准，A即美国，想这个信息时代的基础计算机的发展史前期基本全在美国，这是十几年的积累，无怪乎美国半导体产业这么强。至此计算机硬件最重要的几个部分CPU，RAM，I/O就讲完了，叫做冯诺依曼体系。早期的计算机理论就是出自冯诺依曼，图灵等人的硕士论文，人家这硕士含金量杠杠。并且，ROM会放些初始化程序，如OS。UNIX就是用C写的，有移位操作，按位逻辑操作以及指针是有别于其他语言最显著的特点。DOS，LINUX是文字输入类型OS，Windows是图形界面OS。计算机部件中还有个显卡，提供信号给显示器的电子部件，计算能力据说很强大，比特币矿机就会搞很多显卡来挖矿。

## 书籍：程序员的自我修养 2019.12.31

## 书籍：计算机构造与解释Python版 2021.3.19

是上个月看完 Structure and Interpretation of Computer Programs的Python版本。前天又花了一天时间回顾。真是大开眼界，给你一种完全不同的视角看待程序语言，正如书中所言的magic，art，比如我们都知道program是由procedure和data构成，但我从没想过procedure就是data，data就是procedure。就Python入门而言，对一个C语言程序经验者，这本书非常难懂，难懂在于它的讲述方式跟传统的填鸭式介绍控制语言，数据结构...完全不同，但我反过来想如果对于初心者而言，或许就没有别样的难。当然本书与其说讲解Python，还不如讲是一种通用的程序语言概念，最核心的无非就是抽象和递归，只是拿Python举例了。

第一章讲procedure。程序语言中最基本的概念是什么？表达式（最基础的就是数值本身）和 表达式的绑定。在Python中，在一定范围内的自然数，都是有独立地址的，比如

```
a = 5，b = 5
```

a和b地址就相同，所以相对于C，`=`更确切讲是绑定而不是赋值，`=`提供了最基础的抽象手段。然后是调用表达式（数值+运算符）。运算符本质上就是函数，这里就引出了第一章的主题，函数。进一步稍微复杂一点，函数可以嵌套，提供了组合操作手段。函数由什么组成？语句。表达式、返回语句return和赋值语句等是最简单语句，跟C相较，因为Python可以是屏幕上交互式语言，所以像123这样单独数值的表达式就是一条独立的语句，逗号在赋值语句中分隔了多个名称和值，比如

```
a,b=1,2
```

（这本书很多东西都讲到C基础Python语言学习者的盲点上，有时候正是受困于既定思维，所以阅读此书时方才更为困难）。简单语句其基础上有def（定义），if（条件控制），while（重复）等复合语句。Python 的代码是语句的序列（语句的序列实质上也是个first+rest的递归结构）。一条简单的语句是一行不以分号结束的代码，复合语句一般占据多行，并且以一行以冒号结尾的头部开始，它标识了语句的类型。同时，一个头部和一组缩进的代码叫做子句（借助简单复合语句的概念，去理解Python与C书写格式上的异同）。函数作为一个整体可以作为参数，返回值，跟最基本的表达式一样是语言的一等元素，可以被嵌套定义，高阶函数可以像操作数据一样去操作函数，这里就可以理解为什么procedure是data。Python中对一些没有赋值和控制语句单个返回表达式的函数可以用Lambda 表达式，有点类似于C中的difine，但进一步具有匿名性（即不存在函数名）。此外，还顺道讲了一个语法糖：装饰器，结构上非常费解然而又精巧，用于不修改高阶函数原有代码的前提下对高阶函数功能追加。

第二章讲data。Python 包含了三个原始数值类型：整数（`int`）、实数（`float`）和复数（`complex`）。之后所有的抽象数据类型都是基于此构建起来，最终形成一个Python大厦。首先书中通过有理数的构造过程，来展示抽象的层次。表现为几分之几的有理数数据结构由二元元组(偶对的形式)来实现，而偶对的下标访问方式以及有理数数据结构的运算都能以函数操作原始数值类型来实现（从这个角度上看，偶对或者所构造的有理数就是一个函数，这就说明了为什么data是procedure）。偶对到多元元组就一回事。

这个节点，书中引入了`nonlocal`语句，我们知道函数也是一种数据类型，书中特地分了纯函数和非纯函数，它们之间最本质的区别就是是否可变。前者只要特定的参数，return肯定是不变的，后者假若引进nonlocal变量，return值就是可变的。这里隐含了一个赋值语句的双重作用：创建新的绑定，或者重新绑定现有名称。为了去补救重新绑定的操作引起的认识论问题：它对于两个相同的值意味着什么。（如果清楚C中指针的概念的话，其实就很好理解）。对于不可变类型，值相同对象就相同，对于可变类型就不尽然。所以Python 引入了两个比较运算符，叫做`is`和`is not`，测试了两个表达式实际上是否求值为同一个对象，`is`和是个比相等性`==`更强的比较运算符。

偶对可以嵌套，满足封闭性（封闭性在任何组合手段中都是核心能力），去实现

```
(1, (2, (3, (4, None))))
```

这样的嵌套结构。这个嵌套的结构通常对应了一种非常实用的序列思考方式，一个非空序列可以划分为：它的第一个元素，以及序列的其余部分。这说明了列表是可以基于偶对递归实现，并用函数实现元素的变更（ps Python 的内建list序列类型以不同方式实现）。(传统Python介绍中先介绍list，再是tuple，然后要去解释为什么有了list后还要创造tuple？因为list基于tuple基础上实现嘛，由此可见本书编排精妙之一斑。) 

字典的目的是提供一种抽象，用于储存和获取下标不是连续整数，而是描述性的键的值。所以字典实现上可以通过列表改造而来。至此就完成了从偶对到字典的主要序列容器的构建。（书中还顺手组合了非局部赋值、列表和字典来构建一个基于约束的系统，支持多个方向上的计算。这真是开了我的眼界，理解连接器和约束，把它们看成key为函数名，value为函数过程去理解，最新颖在于这个这个基于约束网络特征的无方向计算。）

我们知道序列的许多操作都是基于迭代的概念，这里就可以引进迭代器。有序序列其实隐含着迭代器接口`__iter__`和`__next__`，Python 拥有额外的控制语句来处理序列数据：`for`语句。

```
>>> counts = [1, 2, 3]
>>> for item in counts:
        print(item)
1
2
3
```

如上例，counts可以通过`__iter__`回应给`for`一个迭代器，然后`for`反复调用`__next__`来实现对序列的遍历。可以通过`while`显式地配合`__next__`来实现`for`语句。程序中的一个常见模式是，序列的元素本身就是序列，`for`语句可在头部中包含多个名称，将每个元素序列“解构”为各个元素。这个绑定多个名称到定长序列中多个值的模式，叫做序列解构。它的模式和我们在赋值语句中看到的，将多个名称绑定到多个值的模式相同。如果不需要解构序列元素，常见的惯例是将单下划线字符用于`for`头部，要注意对解释器来说，下划线只是另一个名称，但是在程序员中具有固定含义，它表明这个名称不应出现在任何表达式中。（这本书说明Python完全是另一套思维，不是既存的`for`去操作序列，而是序列的某些特性需要引入`for`语，而且说`for`语法的每一个点都说到心坎上去了，相较于C，Python中`for`的改造在哪里？妙不可言！其实深入思考一下，C语言中`while`和`for`在汇编层面是一样的，但Python中不然，就因为这个迭代器概念。）

`for`语句常跟`range`配合使用，如

```
>>> for _ in range(3):
        print('Go Bears!')

Go Bears!
Go Bears!
Go Bears!
```

`range`事实上是一种隐式序列，迭代器提供了一种机制，可以依次计算序列中的每个值，但是所有元素不需要连续储存。反之，当下个元素从迭代器获取的时候，这个元素会按照请求计算，而不是从现有的内存来源中获取。这是惰性计算的一个例子。计算机科学将惰性作为一种重要的计算工具加以赞扬。

生成器表达式组合了过滤`filter`和映射`map`的概念，并集成于单一的表达式中，以下面的形式：

```
<map expression> for <name> in <sequence expression> if <filter expression>
```

表达式包含了`map`和`filter`的大部分功能，但是避免了被调用函数的实际创建，实际上也是一种惰性计算。

生成器函数是一种特殊的迭代器，不同于普通的函数，因为它不在函数体中包含`return`语句，而是使用`yield`语句来返回序列中的元素。`yield`与`return`的区别在于，它返回值出去之后仍然可以在当前位置继续执行下去，利用这点可以去构建Python中一种轻量级的线程，即协程（coroutine）。

流提供了一种隐式表示有序数据的最终方式，流是惰性计算的递归列表，就像之前自偶对嵌套构建而来的`list`那样，`Stream`类实例化后可以响应对其第一个元素和剩余部分的获取请求，同样，`Stream`的剩余部分还是`Stream`，然而不像`list`，流的剩余部分只在查找时被计算，而不是事先存储，也就是说流的剩余部分是惰性计算的。（惭愧惭愧，C++中多次接触流，但始终没有理解其本质）。

讲流时提到了对象，而对象正是基本数据抽象最上层的概念，事实上可以通过在实例、类和基类之间发送含有属性的字典作为消息来实现对象系统，只是没法去实现点运算符，书中讲点运算符是 Python 的语法特征，它形成了消息传递的隐喻。（类与方法之间的点可以视作为一个运算符。其实我这个浸淫C多年的coder刚看Python就对这个点运算符比较懵逼。）点运算符隐式地把方法的第一个参数设为了self。可以在pycharm中使用debugger来追踪书中所列出来的例子看一下类与对象是如何建立起来的。先创建类，从外层的类到基类，调用层层深入进去，然后实例化对象，从基类开始往外依此调用初始化函数最终抵达实例。比喻来说，创建时先一层层进去拿到最核心的字典，即基类的字典，然后实例化时在从这个核一层层出来，包裹各层次之间的颜料，最后形成实例。每一个层次的字典（可以理解为方法集）都不一样，就可以理解类与对象各自有相应的方法，某种程度上类似于类与基类，从而也能理解各个层次间方法重载的机制，先是调用实例中的方法，如果找不到，就去类中寻找，并绑定到实例中执行。（另一方面我们也可以理解为什么C的编译器可以用C来编写，因为就如同Python的某些机制如类与对象可以由更为低层次的抽象概念字典与函数来实现一样，语言的建构是一个不断抽象累积的过程。）

第三章实现了一个解释器，前面两章分别讲了编程的两个基本元素procedure和data，事实上，procedure就是data这一点，也可以从用户的程序即是解释器的数据的角度来理解。本章最后有介绍Lsip的两种方言Scheme和Logo的解释器构造：数据求值粗略地来说可以得到基本表达式和函数，这个函数就需要调用过程，而过程中去读取每一行的代码有需要递归去调用数据求值来确定值，从而数据求值与过程互相递归，最终停止于基本表达式。

关于这两种抽象语言的解释器框架，我确实也只一知半解，但能够意识到其核心就是递归：可以通过C写一个Fibonacci数列的递归调用，从汇编层面去理解递归函数：函数前半段不断重复进去递归函数内层，然后后半段不断重复出来到最外层。书中说我们不应该关心`fun(n-1)`如何在`fun`的函数体中如何实现，只需要相信它计算了`n-1`的阶乘，将递归调用看做函数抽象叫做递归的“信仰飞跃”（leap of faith），这说得真好！递归与迭代思考方式上是截然不同的，通常，迭代函数必须维护一些局部状态，它们会在计算过程中改变。在任何迭代的时间点上，状态刻画了已完成的结果，以及未完成的工作总量。

书中以较抽象语言更为简单的计算器语言的解释器构造为例来抛砖引玉，介绍之前先需介绍两个概念：表达式树和字符串。就像第二章介绍的递归列表，树同样可以通过偶对嵌套的封闭性来构造，这里引入Python除tuple，list，dictionary之外第四种容器set来说明树的高效性，set可以由无序集合，有序集合和平衡二叉树集合来实现，它们对于集合的交并等计算而言，效率差别很大。（这些事实上是算法和数据结构的内容，加上编译原理，本书内容其实非常丰富。）

然后是字符串，字符串满足基本的序列容器条件，数据值的字符串表示在类似 Python 的交互式语言中尤其重要，其中“读取-求值-打印”的循环需要每个值都拥有某种字符串表示形式。Python中主要有两种字符串构造函数`str`和`repr`，略有区别。与之紧密相关的概念是接口，响应`__repr__`和`__str__`特殊方法的对象都实现了通用的接口，它们可以表示为字符串，这某种程度上是函数多态的一种表现。（JAVA中抽象类ADT与接口的区别不是常提的嘛）。

回到计算器语言的构造，仍然是可以用pycharm中的debugger来看书中的例子，其基础是构建一个表达式树的类来作为计算器语言的基本对象，比如`add(1,2)`,由operator和operand构成(注意这个类本身可以递归表示为operand，形成复合计算式）。在“读取-求值-打印”循环的交互模式中（一个loop函数），利用词法分析器lexical analysis切割所输入的字符串（代码文本）产生一个token列表，然后利用语法分析器parse去生成表达式树（这里要构建一个递归逻辑去实现复合计算式的实现），中间通过异常机制健壮语法错误检查，最终将表达式树输入计算逻辑函数即semantic analysis得出结果，即输入符合语法的字符串（代码文本）被相应执行。（就C编译器而言，相对Python解释器，多optimization和code generation两个步骤，但前三步原理一样，这比看编译原理简单明了多了！）

之前有看过Lisp版本SICP的英文视频，就是完全云里雾里，也看过浙大python的教学视频，感觉就填鸭死记硬背，等到看了这本Python版本的SICP，非常惊喜，回味起来就感慨这本书的编排之美丽，果真是magic，art。明白别人所讲的：永远不要做一个不知道递归和抽象概念的程序员。